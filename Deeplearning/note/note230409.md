# 手写感知器（23/04/09）



## 编写实现向量计算的类

### 静态函数：

#### dot（计算两个向量的内积）

1.reduce函数：reduce函数用于对列表，元组等可迭代的对象中的所有元素进行累积操作，返回一个单一的结果。reduce() 函数接受两个参数：一个函数和一个可迭代对象。该函数在每个元素上进行操作，并返回一个累积的结果。例如

```
from functools import reduce
lst = [1, 2, 3, 4, 5]
result = reduce(lambda x, y: x*y, lst)
print(result)   # 输出 120，即 1*2*3*4*5
```

2.通过调用`VectorOp.element_multiply(x, y)`计算两个向量相应元素的乘积列表

3.再调用reduce函数将VectorOp.element_multiply返回回来的列表各项相加起来，结果返回

#### element_multiply（将两个列表相应位置相乘得到一个新列表）

1.zip函数：将x和y中相应的元素打包成一个元组，并返回一个迭代器

2.map函数：第一个参数是一个函数，第二个参数是可迭代对象，将第二个参数中的每个元素都执行一遍第一个参数中的函数，结果用list转换成列表对象

#### scala_multiply（将v的每个元素都乘以s）



## 构建感知器类

## 函数

#### 1.初始化函数

定义激活函数，权重列表，偏置

#### 2.打印信息函数

将权重和偏置打印出来

#### 3.预测输出函数

通过调用VectorOp类的dot函数进行计算最终结果并返回

#### 4.训练函数

接收4个参数，分别是一个输入列表input_vecs，里面分别有4个子列表[1,1],[1,0],[0,1],[0,0]，一个标签labels，分别对应输入的四个正确结果，训练迭代次数iteration，以及参数更新速率rate，循环调用_one_iteration函数iteration次

#### 5.单次训练

每次对四个输入进行输出预测，并通过调用更新参数的函数_update_weights更新权重和偏置

#### 6.更新参数

利用真实标签和预测值的差值再乘以速率作为更新的梯度



总结：了解了感知器的工作原理，但是不能独立使用python编写出来，接下来工作先学习一下python的基础知识，再自己独立构建